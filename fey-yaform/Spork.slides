----
presentation_topic: Fey, Another Freakin' ORM
presentation_title: Fey, Another Freakin' ORM
presentation_place: Minneapolis, MN
presentation_date: Saturday, February 5, 2009
----
== What the fuck, Dave?

* Are you high?
* Or just stupid?
----
== Why another ORM?

* Alzabo is old crap
* But I still like parts of it
* Wanted a modern tool without the baggage
----
== Fey anatomy

* |Fey| distro - core modules
* |Fey::Loader|
* |Fey::DBIManager|
* |Fey::Test|
* |Fey::ORM|
** |Fey::ORM::Mock|
----
== Fey core modules

* |Fey::Schema|, |Fey::Table|, |Fey::Column|, |Fey::FK|
** SQL schema in objects
* |Fey::SQL|, |Fey::Literal|, |Fey::Placeholder|
** SQL generation through Perl
----
== Fey core examples

   my $schema = Fey::Schema->new( name => 'my-cds' );

   my $cd_table = Fey::Table->new( name => 'CD' );

   $cd_table->add_column( ... );

* But don't do this! Use Fey::Loader!
----
== Fey core examples

   my $avg_tack_length =
       Fey::Literal::Function->new
           ( 'AVG', $track_table->column('length') );

   my $select = Fey::SQL->new_select();

   $select->select( $track_table )
          # figures out appropriate join
          ->from( $cd_table, $track_table )
          ->where( $cd_table->column('year'), '>',
                   Fey::Placeholder->new() )
          ->and( $track_table->column('length'), '>',
                 $avg_track_length )
          ->order_by( $cd_table->column('name'),
                      $track_table->column('name') );

   # quotes the crap out of everything
   my $sth = $dbh->prepare( $select->sql($dbh) );
   $sth->execute( 1990 );
   
----
== Fey core auto-placeholders

.hilite
my $select = Fey::SQL->new_select();

$select->select( $track_table )
       # figures out appropriate join
       ->from( $cd_table, $track_table )
       ->where( $cd_table->column('year'), '=', 2005 );
       ->and( $cd_table->column('artist_id'), '=',
              $tommy_heavenly6->artist_id() );

my $sth = $dbh->prepare( $select->sql($dbh) );
$sth->execute( $select->bind_params() );

                                                bbbb 6
              bbbbbbbbbbbbbbbbbbbbbbbbbbbbb 8
               gggggggggggggggggggggg 11
.hilite

* Very handy, but can be turned off
** still always does proper quoting
----
== Fey core philosophy
* Leverages your SQL knowledge
** looks SQL-y
** simple data structures, explicit comparisons
----
== Why use it?
* Awfully verbose for simple SQL!
* Primary use case - dynamically generating complex SQL
** I seem to need to do this a lot
** if you don't, Fey may not be for you
----
== Fey core goals
* Make it easier to generate SQL dynamically 
* Support any type of query
** subselects
** complex joins with join constraints

  FROM TableA
       LEFT OUTER JOIN TableB USING (foo_id)
       WHERE TableB.size > 10

----
== Fey core goals
* Be helpful
** auto joins
** ignore the same join twice
* De-coupled from an ORM (unlike Alzabo)
----
== Fey::Loader

* Define your schema in standard SQL
* Point |Fey::Loader| at your DBMS

   my $loader = Fey::Loader->new( dbh => $dbh );
   my $schema = $loader->make_schema();
----
== Fey::Loader

* Works with SQLite, Pg, and MySQL so far
* Uses DBI's |*_info| methods (mostly)
* If your DBMS supports them, making a |Fey::Loader| subclass is easy(ish)
----
== Fey::Loader

* Use it, don't define your schema in Perl
----
== Fey::DBIManager

* Manages a set of 1+ DBI handles
* Primarily for the benefit of |Fey::ORM|
** but works standalone too
* Handles forking & threading properly
* Can be subclassed for DWIMing with master/slave setups
----
== Fey::DBIManager

* Most people will not need to look too closely
* Just set up your |Fey::DBIManager::Source| at load time

----
== Fey::DBIManager example

    package MyApp::Schema;

    my $source =
        Fey::DBIManager::Source->new
            ( dsn          => ...,
              username     => ...,
              password     => ...,
              post_connect => \&_set_dbh_attributes,
            );

    sub _set_dbh_attributes {
        my $dbh = shift;

        $dbh->{pg_enable_utf8} = 1;
        $dbh->do( 'SET TIME ZONE UTC' );
    }
----
== Fey::DBIManager post-connect

* Post-connect gets called whenever |Fey::DBIManager| reconnects
** after a fork or in a new thread
** more or less transparent to you
----
== Fey::ORM

* Builds on top of |Fey| core and |Fey::DBIManager|
* SQL-oriented ORM
** thinking in sets, not objects
** *not* a dumb object store
** design your tables first
* Is extremely Moose
** subclasses Moose metaclasses
** declarative
** you can use all Moose features!
----
== Fey::ORM - MyApp::Schema

.hilite
package MyApp::Schema;

use Fey::ORM::Schema;

{
    my $source = Fey::DBIManager::Source->new( ... );

    my $schema =
        Fey::Loader->new( dbh => $source->dbh() )
                   ->make_schema();

    has_schema $schema;

    __PACKAGE__->DBIManager()->add_source($source);
}

b+ 3
b+ 12
+
b+ 14
.hilite

----
== Fey::ORM - MyApp::Schema methods

* |MyApp::Schema->Schema()| - returns a |Fey::Schema|
----
== Fey::ORM - MyApp::Schema methods

* |MyApp::Schema->DBIManager()|
** returns a |Fey::DBIManager|
* |MyApp::Schema->DBIManager()->default_source()|
** a |Fey::DBIManager::Source|
* |MyApp::Schema->DBIManager()->default_source()->dbh()|
** - a |DBI| handle
----
== Fey::ORM - MyApp::Schema methods
* |MyApp::Schema->SQLFactoryClass()|
** by default, returns |'Fey::SQL'|
** subclass it to return something else - |'Fey::SQL::Pg'|
*** (this does not exist (yet))
* |MyApp::Schema->SQLFactoryClass()->new_select()|
** a |Fey::SQL::Select| object
----
== Fey::ORM - MyApp::Schema methods
* |MyApp::Schema->EnableObjectCaches()|
* |MyApp::Schema->DisableObjectCaches()|
* |MyApp::Schema->ClearObjectCaches()|
* Affects caching for all table-based classes
* Fairly dumb in-memory object cache
** designed to catch attempt to create same object >1 time
----
== Fey::ORM - MyApp::Schema methods
* |MyApp::Schema->RunInTransaction( sub { ... } )|
----
== Fey::ORM - MyApp::Schema::CD

.hilite
package MyApp::Schema::CD;
use MyApp::Schema;
use Fey::ORM::Table;

{
  my $schema = MyApp::Schema->Schema();

  has_table( $schema->table('CD') );

  has_one( $schema->table('Artist') );

  has_many 'tracks' =>
      ( table    => $schema->table('Track'),
        order_by =>
            [ $schema->table('Track') 
                     ->column('track_number') ],
        cache    => 1,
      );
}

b+ 3
b+ 8
+
b+ 10
b+ 12
b+ 13
b+ 14
b+ 15
b+ 16
b+ 17
b+ 18
.hilite
----
== Fey::ORM - MyApp::Schema::CD

  package MyApp::Schema::CD;

  {
     transform 'release_date'
         => deflate { blessed $_[1]
                      ? DateTime::Format::Pg
                            ->format_datetime( $_[1] )
                      : $_[1] }
         => inflate { DateTime::Format::Pg
                          ->parse_datetime( $_[1] ) };
  }
----
== Fey::ORM - MyApp::Schema::CD

  package MyApp::Schema::CD;

  {
     has_many 'artists' =>
         ( table       => $schema->table('Artist'),
           # SELECT Artist.*
           # FROM Track JOIN Artist USING (artist_id)
           # WHERE Track.cd_id = ?
           select      => ..., # Fey::SQL::Select object
           bind_params => sub { $_[0]->cd_id() },
           cache       => 1,
         );
  }
----
== Fey::ORM - MyApp::Schema::CD

* "Select-based" attributes

  has 'track_count' =>
      ( metaclass   => 'FromSelect',
        select      => $select,
        bind_params => sub { $_[0]->cd_id() },
      );

----
== Fey::ORM::Table gives you Moose

  package MyApp::Schema::CD;

  use Fey::ORM::Table;

  # Plain old Moose attributes
  has 'reverse_title' =>
      ( is      => 'ro',
        isa     => 'Str',
        default => sub { reverse $_[0]->title() },
      );

  # Plain old Moose roles
  with 'MyApp::Role::OpticalMedia';

  # Plain old Moose method modifiers
  before 'update' => sub { ... };

* All the power of Moose, plus more!
----
== Fey::ORM::Table methods

* |MyApp::Schema::CD->Table()| - returns a |Fey::Table|
----
== Fey::ORM::Table methods
* |MyApp::Schema::CD->new( cd_id => 12 )|
** loads CD row from DBMS
** can load one row based on any unique key
** can also define alternate "load one row" logic in your class
*** for example, load user based on username & hashed password
* |$cd->title()|, |$cd->release_date()|
** one method per column
----
== Fey::ORM::Table methods
* |MyApp::Schema::CD->insert()|
* |$cd->update( title => 'Frozen Perl Rock Party' )|
* |$cd->delete()|
----
== Fey::ORM::Table - MyApp::Schema::CD methods
* |MyApp::Schema::CD->EnableObjectCache()|
* |MyApp::Schema::CD->DisableObjectCache()|
* |MyApp::Schema::CD->ClearObjectCache()|
----
== More Fey::ORM features

* Tries very hard to be efficient
** minimize # of SQL queries
* |Fey::Object::Iterator|
** uses DBI statement handles behind the scenes
** can return multiple objects in one |$iterator->next()| call
*** a "join iterator"
* use |Fey::SQL| in your model to build complex queries
----
== Fey::ORM MOP

* Full introspection for attributes & methods
* New metaclasses for HasA (has one and has many)
* Like Moose, extendable via the meta API
----
== Fey::ORM is not done!

* Still a work in progress
* Will expand as I use it
* Will probably need some DBMS-specific logic eventually
** either in |Fey::ORM|, |Fey::SQL|, or both
----
== Fey::ORM::Mock

* Data seeding and insert/update/delete tracking
* Ever used |DBD::Mock|?
** it's really annoying
* Built on top of |DBD::Mock|
----
== Fey::ORM::Mock - Data seeding

  use MyApp::Schema;

  my $mock = Fey::ORM::Mock->new
                 ( schema_class => 'MyApp::Schema' )

  $mock->seed_class( 'MyApp::Schema::CD' =>
                     { title  => 'Get Lost',
                       artist => 'Magnetic Fields',
                     },
                     { ... },
                   );

  # next select will see this data

----
== Fey::ORM::Mock - Tracking insert/update/delete

  use MyApp::Schema;

  my $mock = Fey::ORM::Mock->new
                 ( schema_class => 'MyApp::Schema' )

  my $cd = MyApp::Schema::CD->insert(...);
  $cd->delete();

  my $history =
      $mock->recorder()->actions_for('MyApp::Schema::CD');
----
== Fey::Test

* Shared test framework bits for other Fey distros
* Please ignore this unless you want to hack on Fey
----
== Thank you
----
== Bonus: What's wrong with Alzabo?

* Doesn't support multi-row delete or update
* Better SQL generation API (more methods, less data structures)
----
== Bonus: What's wrong with Alzabo?

   $select->select( $track_table )
          # figures out appropriate join
          ->from( $cd_table, $track_table )
          ->where( $cd_table->column('year'), '=', 2005 );
          ->and( $cd_table->column('artist_id'), '=',
                 $tommy_heavenly6->artist_id() );

   # Alzabo way
   $schema->join
       ( select => $track_table,
         join   => [ $cd_table, $track_table ],
         where  =>
            [ [ $cd_table->column('year'), '=', 2005 ],
              [ $artist_table->column('artist_id'), '=',
                $tommy_heavenly6->artist_id() ],
            ],
       );
----
== Bonus: What's wrong with Alzabo?

* SQL generation API is coupled to schema object API is coupled to ORM API
* Alzabo tries too hard to prevent self-foot-ballistic-puncture
** tons of DBMS-specific code
** makes supporting a new DBMS really hard
** ties Alzabo to specific DBMS versions in weird ways
** makes things bulky and inflexible
* By contrast, Fey assumes you know what you're doing
** will generate bad SQL if you ask, but you'll find out soon enough
----
== Bonus: What's wrong with Alzabo?

* Separation of ::Create and ::Runtime classes
** made sense with standard memory available in 2000
* Too much is-a, not enough has-a
* Alzabo-specific schema format (Storable dump)
** screw that, just put your schema in a file of SQL
* No need for Alzabo's GUI tool any more
* Alzabo implements referential integrity in Perl because I was using MySQL
** Fuck MySQL's stupidity - use a real DBMS or suffer the consequences
*** yes, I know about InnoDB
----
== Bonus: What's wrong with Alzabo?

* Alzabo's test suite came well after starting the code. It is *NASTY*!
* Alzabo does too many things in one package
** it's hard to document and explain
