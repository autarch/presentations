<HTML>
<HEAD>
  <LINK REL=stylesheet TYPE="text/css" HREF="style.css">

  <TITLE>Data Structures in Perl</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">

<H1 ALIGN=CENTER>Data Structures in Perl</H1>

<H2 ALIGN=CENTER>Goals</H2>

<P>
The goal of this presentation and web page is to help you get
acquainted with Perl's data structures, and to develop a sense of
which data structures are appropriate for different situations.  We
also explain how Perl's data structures are implemented internally,
which is knowledge you'll need to use data structures effectively.
</P>

<P>
This presentation draws heavily from the Perl built-in documentation
on data structures.  To see it, look at the perldata(1), perlref(1),
perldsc(1), and perllol(1) manpages, probably in that order.
<P>


<H2 ALIGN=CENTER>Table of Contents</H2>

<UL>
  <LI><A HREF="#basic">The basic Perl data structures</A>
  <LI><A HREF="#uses">Appropriate uses of the basic structures</A>
  <LI><A HREF="#refs">References</A>
  <LI><A HREF="#extended">Extended Perl data structures (refs in disguise)</A>
  <LI><A HREF="#real_life">Real-life uses for extended data structures</A>
  <LI><A HREF="#objects">Objects, briefly</A>
</UL>

* How to write programs that rely more on data structures and less on
if/then logic (and why that's good)
* What data structures are appropriate for different situations
* How to recognize programs that need different data structures
* How a good data structure can make your life a lot easier


<H2 ALIGN=CENTER><A NAME="basic">The basic Perl data structures</A></H2>

<H3>Scalars</H3>

<P>
The basic unit of data in Perl is the scalar variable.  It can hold
"one thing."  That thing might be a number like 2 (an integer), or a
number like 3.7 (a float), or a bunch of characters like "hi mom" (a
string), or something more exotic (a reference - more later), or
nothing at all (undef).
</P>

<P>
Perl will automatically convert from one kind of scalar to another.
For instance, you can create a scalar as a string, then later use it
as a number:
</P>

<PRE>
  $var = "2.7";      # It's a string.
  $total = $var + 7; # Use it as an integer - it's fine.
</PRE>

<P>
Scalars always have the '$' character in front of them, without any
exceptions I can think of.  And there's not a whole lot to say about
scalars, so let's move on.
</P>

<H3>Arrays</H3>

<P>
Arrays are a simple way to manage an ordered collection of scalars.
It's like a tie rack for a bunch of neckties - it's just a container
for managing the scalars.
</P>

<pre>
   @pat = ("male", 25, "circus clown");
   $pat[0] = "female"; # perform an operation
   print "$pat[1]\n";  # prints 25 and a newline character
</pre>

<P>
Notice that when you want to refer to the array as a group, you use '@',
the array character.  When you want to refer to a specific scalar
inside the array, you use '$', the scalar character.
</P>

<P>
Since arrays are available in almost all computer languages, people
who are new to Perl use lots of them.  The reality is that a lot of
(most?) things they're using arrays for could be done more cleanly
with hashes.  Keep this in mind.
</P>

<P>
Terminology clarification: some people confuse the terms "array" and
"list."  An array is a Perl data structure that carries around its
name (if it has one), its size, how much memory is allocated for it,
and so on.  A list is simply a bunch of things written in a row,
usually with commas in between them and parentheses around them.  In
the following code, the left side is an array and the right side is a
list: 
</P>

<PRE>
   @numbers = (1,4,3,7,9);
</PRE>

<P>
Some of the important Perl functions for dealing with arrays are:
<UL>
  <LI><TT>pop, push, shift, splice, unshift</TT> (for arrays)
  <LI><TT>grep, join, map, qw/WORD WORD/, reverse, sort, unpack, split</TT> (for any list)
</UL>
The triggers in your brain that should make you use arrays in your
programs include:
<UL>
  <LI>ordered data
  <LI>small numbers for indexes
</UL>
</P>



<H3>Hashes</H3>

<P>
Hashes are your friends.  The big difference between hashes and arrays
is that arrays are indexed by number (i.e. $array[1] or $array[5]),
whereas hashes are indexed by string (i.e. $people{"pat"} or
$people{"gary"}).  This doesn't seem like much at first, but it really
can make your programs much better.
</P>

<P>
One important thing to remember about hashes (this can come in quite
handy sometimes) is that you can't have two entries in the hash with
the same key.  For example, after running the following code, you will
have only one key and one value in the hash, not two of each:
</P>

<PRE>
   my %age = ();  # Make an empty hash
   $age{'bob'} = 25;
   $age{'bob'} = 30;  # We just blew away the previous value
</PRE>

<P>
Hashes, lists, and arrays can be closely related.  For instance, you
can pass data back and forth between them using techniques like the
following:
</P>

<PRE>
   my %people = (03345 => 'joe',        # We use a list to initialize
                 48823 => 'yolanda',    # the hash.  The arrow => acts just
		 33229 => 'buddha',     # like a comma.
		);
   my @people_ids = keys %people;

   my @fields = qw(order_id status sub_total order_amount shipping_amount);
   my %data;
   @data{@fields} = &read_data_from_file($filename);  # Use a hash slice

   # While we're at it...
   my @ids = (1,2,3,3,2,4,4,3,7);
   my @unique = keys %{{ map {$_,1} @ids }};  # (1,2,3,4,7) (in any order)
</PRE>

<P>
Some of the important Perl functions for dealing with hashes are:
<UL>
  <LI><TT>keys, values, delete, each, exists</TT> (for hashes)
  <LI><TT>grep, join, map, qw/WORD WORD/, reverse, sort, unpack</TT> (for any list)
</UL>
The triggers in your brain that should make you use hashes in your
code should include:
<UL>
   <LI>keys & values
   <LI>unique
   <LI>translation tables
   <LI>sets & set logic
   <LI>named parameters
   <LI>non-ordered data
</UL>
The combination of "sets & set logic" and "non-ordered data" mean that
hashes are the perfect tool to use with SQL databases - SQL databases
have the same properties.
</P>



<H2 ALIGN=CENTER><A NAME="uses">Appropriate uses of the basic structures</A></H2>

<H3>1. Data mappings</H3>

You see a lot of code like this around:

<PRE>
   my $code_id;
   if ($some_var eq 'value1') {
      $code_id = '03';
   } elsif ($some_var eq 'value2') {
      $code_id = '14';
   } elsif ($some_var eq 'value3') {
      $code_id = '52';
   } elsif ($some_var eq 'value4') {
      $code_id = '06';
   }
</PRE>

<P>
That's bad, because you can't clearly see the relationship between the
keys & values, and you need to have a flowchart in your head to figure
out what's going on (humans don't think in flowcharts).  In practice,
these things can go on for pages and pages, and they're a bear to
maintain.  Here's a better solution, using a hash:
</P>

<PRE>
   my %translation = (value1 =&gt; '03',
                      value2 =&gt; '14',
                      value3 =&gt; '52',
                      value4 =&gt; '06');

   my $code_id = $translation{$some_value};
</PRE>

<P>
Now the data mapping is clearly laid out - you can see the
relationship between the keys & values very clearly.  You also don't
have to follow all the if() blocks to see whether they do something a
little bit different.  The code is also much smaller in page length,
number of statements, and complexity, even though it does exactly the
same thing.  What's more, you can set up the hash once at the top of
the program (or read it from a file or database) and use it several
times throughout the program.
</P>


<H3>2. Database queries</H3>

<P>
Here's some problem code:
</P>

<PRE>
   my ($product_id, $bundle, $description, $last_changed, $notes,
       $product_name, $ref_product, $shipping_id, $site_id, $cross_product_id);

   ($product_id, $bundle, $description, $last_changed, $notes,
    $product_name, $ref_product, $shipping_id, $site_id, $cross_product_id)
      = $db-&gt;select_one_row('sql'=&gt;"SELECT product_id, bundle, description, last_changed, notes,
                                    product_name, ref_product, shipping_id, site_id, cross_product_id
                                    FROM ec_products WHERE product_id = :1",
                            'bind'=&gt;[44285]);

   ($product_id, $bundle, $description, $last_changed, $notes,
    $product_name, $ref_product, $shipping_id, $site_id, $cross_product_id)
      = &fixup_my_data($product_id, $bundle, $description, $last_changed, $notes,
                       $product_name, $ref_product, $shipping_id, $site_id, $cross_product_id);

   print FILE "$product_id,$bundle,$description,$last_changed,$notes,$product_name,",
              "$ref_product,$shipping_id,$site_id,$cross_product_id\n";
</PRE>

<P>
Yow.  Your eyes should glaze over when you look at something like
that.  That's a lot of variables, and you're really doing the same
thing with all of them.  What happens if you want to change the order
of the fields?  Should you change the order that &fixup_data expects
them in too?
</P>

<P>
Why not use an aggregate data structure instead of a million scalars?
</P>

<PRE>
   my @fields = qw(product_id bundle description last_changed notes
                   product_name ref_product shipping_id site_id cross_product_id);

   my %data;
   my $sql = "SELECT " . join(',' @fields) . "FROM ec_products WHERE product_id = :1";
   @data{@fields} = $db-&gt;select_one_row('sql'=$sql, 'bind'=&gt;[44285]);

   &fixup_my_data(\%data);
   print FILE join(',' @data{@fields}), "\n";
</PRE>

<P>
The first thing to note is that we only had to type the names of the
fields <B>once</B>, instead of <B>six times</B> in the original code.
That's a big win - now, if we want to change the order of the fields,
or change which fields we select, we only make the change in one
place.  In the original code we'd have to make it in the first place,
and then deal with the ripple effects of that change in several
different places.
</P>

<P>
The second thing to notice is that we now have only 3 variables in all
that code (4 if you count the database handle), instead of one for
every column in the database.
</P>

<P>
A final thing to notice is that the call to &fixup_my_data got a
heck of a lot simpler.  The guts of that routine will also be much
cleaner now, because they'll be working with self-explanatory things
like $data-&gt;{site_id} instead of something like $data[8].
</P>

<P>
In fact, because hashes are so useful when working with relational
databases, you might as well use the <code>select_row_hash()</code> method
in DRDB.pm:
</P>

<PRE>
   my @fields = qw(product_id bundle description last_changed notes
                   product_name ref_product shipping_id site_id cross_product_id);

   my %data = $db-&gt;select_row_hash('columns' =&gt; \@fields,
                                   'from'    =&gt; 'ec_products',
                                   'where'   =&gt; 'product_id = :1',
                                   'bind'    =&gt; [44285]);
   &fixup_my_data(\%data);
   print FILE join(',' @data{@fields}), "\n";
</PRE>

<P>I like that the best.</P>


<H2 ALIGN=CENTER><A NAME="refs">References</A></H2>

<P>
References in Perl are a very useful thing to know about.  They're new
in Perl 5, and they made life a whole lot better for Perl programmers.
If you know some C programming, you're probably familiar with the
concept of pointers; Perl references are quite similar, but without a
lot of the headaches pointers can cause.
</P>

<P>
The easiest way to make a reference is to put a backslash in front of
the thing you want to make a reference to:
</P>

<PRE>
   my @array = qw(zero one two three four);
   my $array_ref = \@array;

   &some_sub($array_ref);  # &some_sub can manipulate (and change) @array.
   push @$array_ref, "five";
   $array_ref-&gt;[2] = "trois";
</PRE>

<P>
The last two lines show two different ways of <B>"dereferencing"</B>
the reference.  You can use the @ (or $ if it's a scalar reference, or
% if it's a hash reference) to tell Perl you want "the array
referenced by $array_ref".  Or you can use the arrow -&gt; to dereference
and lookup data at the same time.  $array_ref-&gt;[2] is the same thing
as $$array_ref[2], but it's a little clearer.  This is especially true
when you start building multi-dimensional data structures - your
dereferencing can look really hairy if you're not careful.
</P>

<P>
References are handy when you need to pass one or more arrays or
hashes to a subroutine.  Instead of passing all the individual values
<em>inside</em> the array, you just pass a reference to the array
itself:
</P>

<PRE>
   my @people = qw(joe bob cindy);
   &fixup(\@people);
   print "people: @people\n";
   # The above line prints "people: Joe Bob Cindy\n"
   
   sub fixup {
      my $aref = shift;

      foreach my $person (@$aref) {
         $person = ucfirst $person;
      }
   }
</PRE>

<P>
They're also handy when you want to pass more than one list to a
subroutine, because you can simply pass a reference to each item.
Before Perl 5, you couldn't do this without using some pretty esoteric
features of Perl.
</P>

<P>
You can also create anonymous references, like so:
</P>

<PRE>
   my $people = ["mary", "bill"];  # use square brackets
   # The above is like:
   # my $people;
   # {
   #   my @orig_people = ("mary", "bill");
   #   $people = \@orig_people;
   # }

   my $map = {"limburger" =&gt; "cheese"};  # use curly brackets
   # The above is like:
   # my $map;
   # {
   #   my %orig_map = ("limburger" =&gt; "cheese");
   #   $map = \%orig_map;
   # }

</PRE>

<H2 ALIGN=CENTER><A NAME="extended">Extended Perl data structures (refs in disguise)</A></H2>

<P>
Sometimes your data is more complicated than what you can put in an
array or hash simply.  For instance, you might have a bunch of
customers, each of which has a customer ID, a name, and an address.
In this case, you'll benefit greatly from using an <B>extended data
structure</B> (my own term) to store your data instead of some ad-hoc
creation using simple structures.  Extended structures can do pretty
much everything a C structure can do, but they're more flexible.
</P>

<P>
Extended data structures can sometimes look pretty simple.  The
easiest extended structures are the 2-dimensional array and the
2-dimensional hash:
</P>

<PRE>
   $screen[24][1] = 'green';
   
   $customers{'44934'}{'name'} = "Joe Roberts";
   $customers{'44934'}{'address'} = "1194 Gershwin St.";
</PRE>

<P>
You can do 3- or n-dimensional structures the same way.  You can even
mix hashes and arrays by doing things like <code>$schedule{'ken'}[8] =
"feed the cat"</code>.  That means that at 8 in the morning, it's time
to feed the cat.
</P>

<P>
The way these things are implemented inside Perl is by using
references.  The above code could have been written:
</P>

<PRE>
   $screen[24] = [];
   ${$screen[24]}[1] = 'green';
   
   $customers{'44934'} = {};
   ${$customers{'44934'}}{'name'} = "Joe Roberts";
   ${$customers{'44934'}}{'address'} = "1194 Gershwin St.";
</PRE>

<P>
Or, if you prefer:
</P>

<PRE>
   $screen[24] = [undef, 'green'];
   
   $customers{'44934'} = {'name' =&gt; "Joe Roberts",
                          'address' =&gt; "1194 Gershwin St.",
			 };
</PRE>

<P>
For more on extended data structures, see the perlref(1), perldsc(1),
and perllol(1) manpages.
</P>


<H2 ALIGN=CENTER><A NAME="real_life">Real-life uses for extended data structures</A></H2>

<P>
Here's a common task: extract all the information about a given order
from the database.  If you put it into a nice data structure, you can
pass that structure around cleanly to different routines, walk through
the data structure, and generally have a nice experience programming &
maintaining code.  If you like, you can also use a structure that
reflects the actual structure in the database, so that there's only one
kind of conceptual picture of the data that you have to deal with.
Doing so may also make it easier for other people to read your code if
they're familiar with the database structure.
</P>

<PRE>
  # The list of fields we care about
  my @order_fields = qw(order_id cust_id order_amount order_date
			shipping_amount site_id special_instructions status sub_total
	                suspended tax_amount);

  my %order = $db->select_row_hash('columns' => \@order_fields,
                                   'from'    => 'ec_orders',
				   'where'   => 'order_id = :1',
				   'bind'    => [123456],
				  );

  my @item_fields = qw(version_id net_price quantity);
  my $sql = 'SELECT '. join(',',@item_fields). ' FROM ec_order_items WHERE order_id = :1';
  my $st = $db->begin_statement(sql=>$sql);
  my @data;
  while (@data = $st->next_row) {
     my $version_id = $data[0];
     $order{'line_items'}{$version_id} = {map {$item_fields[$_], $data[$_]} 1..$#item_fields};
  }

  # Now here's the structure of %order:
  %order = (
            'order_id' => 123456,
	    'cust_id'  => 332444, 
	     ...
            'tax_amount' => 33.21,
	    'line_items' => 
	                   { 88321 => { 'net_price' => 442.43, 'quantity' => 1 },
	                     88322 => { 'net_price' => 424.43, 'quantity' => 1 } },
           );
</PRE>


<H2><A NAME="objects">Objects, briefly</A></H2>

<P>
I'll be brief.  Perl objects are references, plain and simple.  They
can be hash references, array references, scalar references, GLOB
references, or whatever, but they're almost always hash references
because they seem to usually be the most convenient.  To turn a
regular reference into an object, you call Perl's <code>bless</code>
function, which just associates the object with a particular class (in
the form of a Perl package).
</P>

<P>
Perl objects are probably the subject of another whole presentation,
so that's all we'll say now.
</P>

<HR>


<ADDRESS>Created in 1999 by Ken Williams for Digital River.</ADDRESS>

</BODY>
</HTML>
